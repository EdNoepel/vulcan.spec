# Vat.init.call
# -> create Ilk id: e.ilk
# Cat.file.call
# -> update Ilk id: e.ilk => ilks[e.ilk].chop ilks[e.ilk].lump ilks[e.ilk].flip
# -> create FileEvent id: e.ilk
# Frob.file(ilk _).call
# -> update Ilk id: e.ilk => ilks[e.ilk].spot ilks[e.ilk].line
# -> create FileEvent id: e.ilk
# Drip.file(ilk _).call
# -> update Ilk id: e.ilk => ilks[e.ilk].tax ilks[e.ilk].rho
# -> create FileEvent id: e.ilk
# Vat.fold.call
# -> update Ilk id: e.ilk => ilks[e.ilk].rate
# Vat.toll.call
# -> update Ilk id: e.ilk => ilks[e.ilk].take
# Vat.frob.call
# -> update Ilk id: e.ilk => ilks[e.ilk].Ink ilks[e.ilk].Art
# Vat.tune.call
# -> update Ilk id: e.ilk => ilks[e.ilk].Ink ilks[e.ilk].Art
type Ilk {
  id:    String      # param: e.ilk                  desc: ilk identifier e.g ETH
  take:  Float       # storage: Vat.ilks[id].take    desc: rate scaling factor
  rate:  Float       # storage: Vat.ilks[id].rate    desc: debt scaling factor
  spot:  Float       # storage: Pit.ilks[id].spot    desc: price feed with margin
  line:  Float       # storage: Pit.ilks[id].line    desc: debt ceiling
  chop:  Float       # storage: Cat.ilks[id].chop    desc: liquidation penalty
  lump:  Float       # storage: Cat.ilks[id].lump    desc: flip auction lot size
  flip:  Address     # storage: Cat.ilks[id].flip    desc: flipper contract
  rho:   Era         # storage: Drip.ilks[id].tax    desc: time of last drip
  tax:   Float       # storage: Drip.ilks[id].rho    desc: tax
  Ink:   Float       # storage: Vat.ilks[id].Ink     desc: total encumbered Gem
  Art:   Float       # storage: Vat.ilks[id].Art     desc: total debt outstanding
  files: [FileEvent] # obj: FileEvent(id: id)        desc: risk param state change events
  bites: [BiteEvent] # obj: BiteEvent(ilkId: id)     desc: ilk bite events
  frobs: [FrobEvent] # obj: FrobEvent(ilkId: Id)     desc: ilk frob events
  created: Datetime
  updated: Datetime
}

# Pit.file(what _).call
# -> update PitGov id: e.address => Pit.Line
# -> create FileEvent id: e.address
type PitGov {
  id:      String       # param: e.address           desc: contract address
  Line:    Float        # storage: Line              desc: system debt ceiling
  files:   [FileEvent]  # obj: FileEvent(id: id)     desc: state change events
  created: Datetime
  updated: Datetime
}

# Drip.file(what _).call
# -> update DripGov id: e.address => Drip.repo Drip.vow
# -> create FileEvent id: e.address
type DripGov {
  id:      String       # param: e.address           desc: contract address
  repo:    Float        # storage: repo              desc: debt scaling factor
  tax:     Float        # storage: tax               desc: debt scaling factor
  files:   [FileEvent]  # obj: FileEvent(id: id)     desc: state change events
  created: Datetime
  updated: Datetime
}

type Urn {

  # Persisted urns mapping
  # Urn state updated via `frob` and `bite` actions.

  ilkId:  String  # unique identifier e.g. ETH
  ilk:    Ilk     # ilk object
  urn:    String  # urn identifier
  ink:    Float   # locked gem
  art:    Float   # outstanding debt
  rat:    Float   # (ink * ilk.spot) / (art * ilk.rate)
  safe:   Boolean # ratio > 1
  frobs:  [FrobEvent]  # state change events
  bites:  [BiteEvent]  # liquidation events
  created: Datetime
  updated: Datetime
}

# Cat.bite.call
# -> create Flip id: e.nflip
# -> create BiteEvent id: e.nflip
type BiteEvent {
  id:      Integer  # storage: flips[nflip]                 desc: flip identifier
  ilkId:   String   # param:   e.ilk                        desc: ilk identifier
  ilk:     Ilk      # obj:     Ilk(id: ilkId)               desc: ilk object
  urnId:   String   # param:   e.urn                        desc: urn identifier
  urn:     Urn      # obj:     Urn(id: urnId, ilkId: IlkId) desc: urn object
  ink:     Float    # storage: ilks[e.ilk].ink              desc: siezed collateral
  art:     Float    # storage: ilks[e.ilk].art              desc: siezed debt
  tab:     Float    # param:   e.tab                        desc: debt to recover including liq. penalty
  bids:    [Bid]    # obj:     Bid(flipId: id)              desc: collateral auction(s)
  flip:    Flip     # obj:     Flip(id: id)                 desc: flip state
  tx:      Tx       #                                       desc: transaction meta
}

# Cat.flip.call
# -> create FlipEvent id: e.n
# -> update Flip id: e.n
# -> create Bid id: e.id
type FlipEvent {
  id:      Integer  # param: e.n             desc: flip identifier
  wad:     Float    # param: e.wad           desc: flip amount
  tx:      Tx       #                        desc: transaction meta
}

# Cat.bite.call -> create Flip id:nflip
# Cat.flip.call -> update Flip id:n
type Flip {
  id:      Integer  # param n | nflip           desc: flip identifier
  ink:     Float    # storage: flips[n].ink     desc: remaining collateral to auction
  tab:     Float    # storage: flips[n].tab     desc: remaining debt to recover
  created: Datetime
  updated: Datetime
}

type Sin {

  # Persisted sin queue mapping
  # Sin state updated via `Cat.bite` and `Vow.flog` actions.

  era:     Era      # bite timestamp
  tab:     Float    # sin amount
  bites:   [BiteEvent] # bite events
  flog:    Flog     # flog event
  flogged: Boolean  # true if flogged
  created: Datetime
  updated: Datetime
}

# Governance state change Event
# file.call -> create FileEvent
type FileEvent {
  id:    String   # param: e.ilk || e.address desc: ilk identifier or contract address
  what:  String   # param: e.what             desc: field to update
  data:  String   # param: e.data             desc: parsed data - number or address
  tx:    Tx       #                           desc: transaction meta
}

# State change Event
type FrobEvent {
  ilkId: String   # ilk identifier
  urn:   String   # urn identifier
  dink:  Float    # ink delta
  dart:  Float    # art delta
  tx:    Tx       # transaction meta
}

# State change Event
type FlogEvent {
  tx:     Tx       # transaction meta
}

type Query {

   # Collection Arguments
   # first: Only read the first `n` values # of the set.
   # last: Only read the last `n` values # of the set.
   # offset: Skip the first `n` values from our `after`
   # cursor, an alternative to cursor based pagination. May
   # not be used with `last`.
   # before: Read all values in the set
   # before (above) this cursor.
   # after: Read all values in the set
   # after (below) this cursor.
   # orderBy: The method to use when ordering `OasisTrade`.
   # condition: A condition to be used in determining which values should be
   # returned by the collection.
   # filter: A filter to be used in determining which values should be returned
   # by the collection.

   allIlks(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   IlkOrderBy,
     condition: IlkCondition,
     filter:    IlkFilter
   ): [Ilk]

   allIlkStates(
     # Collection arguments
     # ...
     interval: String # optionally specify a postgres aggregation interval e.g '1 day'
   ): [Ilk]

   getIlk(
     id: String!
     blockNumber: Int # optionally retrieve ilk state at a given block height
   ): Ilk

   allUrns(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   UrnOrderBy,
     condition: UrnCondition,
     filter:    UrnFilter
   ): [Urn]

   getUrn(
     ilkId: String!
     urnId: String!
     blockNumber: Int # optionally retrieve ilk state at a given block height
   ): Urn

   allUrnStates(
     # Collection arguments
     # ...
     interval: String # optionally specify a postgres aggregation interval e.g '1 day'
   ): [Urn]

   allFiles(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   FileOrderBy,
     condition: FileCondition,
     filter:    FileFilter
   ): [FileEvent]

   allFrobs(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   FrobOrderBy,
     condition: FrobCondition,
     filter:    FrobFilter
   ): [FrobEvent]

   allBites(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   BiteOrderBy,
     condition: BiteCondition,
     filter:    BiteFilter
   ): [BiteEvent]
}
