type Ilk {

  # Persisted ilks mapping
  # Ilk state updated via `file` actions across multiple MCD contracts
  # Ink and Art updated via `frob` and  `bite` events

  id:   String    # ilk identifier e.g ETH
  take: Float     # rate scaling factor
  rate: Float     # debt scaling factor
  spot: Float     # price feed with margin
  line: Float     # debt ceiling
  chop: Float     # liquidation penalty
  lump: Float     # flip auction lot size
  flip: Address   # flipper contract
  rho: Era        # time of last drip
  tax: Float      # tax
  Ink: Float      # total encumbered Gem
  Art: Float      # total debt outstanding
  files: [File]   # risk param state change events

}

type Urn {

  # Persisted urns mapping
  # Urn state updated via `frob` and `bite` actions.

  ilkId:  String  # unique identifier e.g. ETH
  ilk:    Ilk     # ilk object
  lad:    Address # urn owner public key
  ink:    Float   # locked gem
  art:    Float   # outstanding debt
  rat:    Float   # (ink * ilk.spot) / (art * ilk.rate)
  safe:   Boolean # ratio > 1
  frobs:  [Frob]  # state change events
  bites:  [Bite]  # liquidation events
}

# Ilk State change event
type File {
  ilkId: String   # ilk identifier
  what:  String   # field to update
  addr:  Address  # present when data is address
  val:   Float    # present when data is a number
  tx:    Tx       # transaction meta
}

# Ilk, Urn State change event
type Frob {
  ilkId: String   # ilk identifier
  lad:   String   # urn owner
  dink:  Float    # ink delta
  dart:  Float    # art delta
  tx:    Tx       # transaction meta
}

# Ilk, Urn State change event
type Bite {
  ilkId:  String   # ilk identifier
  lad:    String   # urn owner
  flipId: Integer  # flip identifier
  tx:     Tx       # transaction meta
}

type Flip {

  # Persisted flips mapping
  # Flip state updated via `bite` and `flip` actions.

  id:      Integer  # flip id
  ilkId:   String   # ilk identifier
  urn:     Address  # urn owner (Urn.lad)
  ink:     Float    # siezed ink
  art:     Float    # siezed collateral
  tab:     Float    # gem amount to recover
  flipped: Integer  # true if gem has gone to auction
  bidId:   Integer  # Bid identifier if flipped
  bid:     Bid      # Bid object

}

type Query {

   # TODO
   # Aggregate queries e.g Ink, Art and Spot time series

   # Collection Arguments
   # first: Only read the first `n` values # of the set.
   # last: Only read the last `n` values # of the set.
   # offset: Skip the first `n` values from our `after`
   # cursor, an alternative to cursor based pagination. May
   # not be used with `last`.
   # before: Read all values in the set
   # before (above) this cursor.
   # after: Read all values in the set
   # after (below) this cursor.
   # orderBy: The method to use when ordering `OasisTrade`.
   # condition: A condition to be used in determining which values should be
   # returned by the collection.
   # filter: A filter to be used in determining which values should be returned
   # by the collection.
   allIlks(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   IlkOrderBy,
     condition: IlkCondition,
     filter:    IlkFilter
   ): [Ilk]

   # Arguments
   # id: Ilk identifier e.g ETH
   # blockNumber: Optionally retrieve Ilk state at a given block height
   getIlk(
     id: String!
     blockNumber: Int
   ): Ilk

   allUrns(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   IlkOrderBy,
     condition: IlkCondition,
     filter:    IlkFilter
   ): [Urn]

   # Arguments
   # ilk: Ilk identifier e.g ETH
   # urn: Urn owner public key
   # blockNumber: Optionally retrieve Urn state at a given block height
   getUrn(
     ilkId: String!
     lad: String!
     blockNumber: Int
   ): Urn

}

# Sin queue
type Sin {
  era:     Era      # bite timestamp
  tab:     Float    # sin amount
  flogged: Integer  # 0 or block number at flog
  events:  [Event]  # Fess and flog events
}

# Vat dai movements
type Transfer {
  src:   Address # from
  dst:   Address # to
  amt:   Float   # amount
  act:   Float   # vat action
  tx:    Tx      # tx meta
}

# Transaction metadata
type Tx {
  transactionHash:  String
  transactionIndex: Integer
  blockHash:        String
  blockNumber:      Integer
  blockTimestamp:   Era
  from:             Address
  to:               Address
  logs:             [Log]
}

type Era {
  int: Integer  # seconds since the epoch
  iso: Datetime # ISO 8601 UTC
}
