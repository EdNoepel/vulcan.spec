# TODO - cage
#      - bite id uniqueness
# -----------------------------------------------------------------------------
# Ilk state-change triggers
# -----------------------------------------------------------------------------
# Spot.file(pip) -> update Ilk id: e.ilk => ilks[e.ilk].pip  | IlkFileEvent
# Spot.file(mat) -> update Ilk id: e.ilk => ilks[e.ilk].mat  | IlkFileEvent
#
# Cat.file(chop) -> update Ilk id: e.ilk => ilks[e.ilk].chop | IlkFileEvent
# Cat.file(lump) -> update Ilk id: e.ilk => ilks[e.ilk].lump | IlkFileEvent
# Cat.file(flip) -> update Ilk id: e.ilk => ilks[e.ilk].flip | IlkFileEvent
#
# Jug.file(duty) -> update Ilk id: e.ilk => ilks[e.ilk].duty | IlkFileEvent
# Jug.drip       -> update Ilk id: e.ilk => ilks[e.ilk].rho  |
#
# Vat.init       -> create Ilk id: e.ilk                     |
# Vat.fold       -> update Ilk id: e.ilk => ilks[e.ilk].rate |
# Vat.frob       -> update Ilk id: e.ilk => ilks[e.ilk].Art  | FrobEvent
# Vat.grab       -> update Ilk id: e.ilk => ilks[e.ilk].Art  |
# Vat.file(dust) -> update Ilk id: e.ilk => ilks[e.ilk].dust | IlkFileEvent
# Vat.file(line) -> update Ilk id: e.ilk => ilks[e.ilk].line | IlkFileEvent
# Vat.file(spot) -> update Ilk id: e.ilk => ilks[e.ilk].spot | IlkFileEvent
#
# Vow.file(wait) -> update Ilk id: e.ilk => ilks[e.ilk].wait | IlkFileEvent
# Vow.file(bump) -> update Ilk id: e.ilk => ilks[e.ilk].bump | IlkFileEvent
# Vow.file(sump) -> update Ilk id: e.ilk => ilks[e.ilk].sump | IlkFileEvent
# Vow.file(hump) -> update Ilk id: e.ilk => ilks[e.ilk].hump | IlkFileEvent

# -----------------------------------------------------------------------------
# Ilk Object
# -----------------------------------------------------------------------------
type Ilk {
  id:    String         # param: e.ilk                   desc: ilk identifier e.g ETH
  pip:   Address        # store: Spot.ilks[id].pip       desc: price feed contract
  mat:   Address        # store: Spot.ilks[id].mat       desc: liquidation ratio
  chop:  Float          # store: Cat.ilks[id].chop       desc: liquidation penalty
  lump:  Float          # store: Cat.ilks[id].lump       desc: flip auction lot size
  flip:  Address        # store: Cat.ilks[id].flip       desc: flipper contract
  rho:   Era            # store: Jug.ilks[id].rho        desc: time of last drip
  tax:   Float          # store: Jug.ilks[id].duty       desc: tax
  Art:   Float          # store: Vat.ilks[id].Art        desc: total debt outstanding
  rate:  Float          # store: Vat.ilks[id].rate       desc: debt scaling factor
  spot:  Float          # store: Vat.ilks[id].spot       desc: price feed with margin
  line:  Float          # store: Vat.ilks[id].line       desc: debt ceiling
  dust:  Float          # store: Vat.ilks[id].dust       desc: debt floor
  wait:  Float          # store: Vow.ilks[id].wait       desc: flop delay
  bump:  Float          # store: Vow.ilks[id].bump       desc: flap lot size
  sump:  Float          # store: Vow.ilks[id].sump       desc: flop lot size
  hump:  Float          # store: Vow.ilks[id].hump       desc: surplus buffer
  files: [IlkFileEvent] # query: IlkFileEvent(ilkId: id) desc: state change events
  bites: [BiteEvent]    # query: BiteEvent(ilkId: id)    desc: ilk bite events
  frobs: [FrobEvent]    # query: FrobEvent(ilkId: id)    desc: ilk frob events
  created: Datetime
  updated: Datetime
}
# -----------------------------------------------------------------------------
# Ilk gov (file) event object
# -----------------------------------------------------------------------------
type IlkFileEvent {
  ilkId: String     # param: e.ilk              desc: ilk identifier
  what:  String     # param: e.what             desc: field to update
  data:  String     # param: e.data             desc: parsed data - number or address
  tx:    Tx         #                           desc: transaction meta
}

# -----------------------------------------------------------------------------
# Urn state-change triggers
# -----------------------------------------------------------------------------
# Vat.frob -> update Urn id: e.u ilkId: e.i => urns[urn].ink | FrobEvent
#                                           => urns[urn].art |
# Cat.bite -> update Urn id: e.u ilkId: e.i => urns[urn].ink | BiteEvent
#                                           => urns[urn].art |
# -----------------------------------------------------------------------------
# Urn Object
# -----------------------------------------------------------------------------
type Urn {
  id:      String       # param: e.urn                                desc: urn identifier
  ilkId:   String       # param: e.ilk                                desc: ilk identifier
  ilk:     Ilk          # query: Ilk(id: ilkId)                       desc: ilk object
  ink:     Float        # store: urns[iLk][urn].ink                   desc: locked gem
  art:     Float        # store: urns[ilk][urn].art                   desc: outstanding debt
  ratio:   Float        # query: (ink * ilk.spot) / (art * ilk.rate)  desc: collateralization ratio
  safe:    Boolean      # query: ratio > 1                            desc: true if sufficiently collateralized
  frobs:   [FrobEvent]  # query: FrobEvent(ilkId: ilkId urnId: id)    desc: state change events
  bites:   [BiteEvent]  # query: BiteEvent(ilkId: ilkId urnId: id)    desc: liquidation events
  created: Datetime
  updated: Datetime
}
# -----------------------------------------------------------------------------
# Urn Frob Event Object
# -----------------------------------------------------------------------------
type FrobEvent {
  ilkId: String      # param: e.ilk              desc: ilk identifier
  ilk:   Ilk         # query: Ilk(               desc: ilk object at event block height
                     #   id:    ilkId,
                     #   block: tx.blockNumber
                     # )
  urnId: String      # param: e.urn              desc: urn identifier
  urn:   Urn         # query: Urn(               desc: urn object at event block height
                     #   id:    urnId,
                     #   ilkId: ilkId,
                     #   block: tx.blockNumber
                     # )
  dink:  Float       # param: e.dink             desc: ink delta
  dart:  Float       # param  e.dart             desc: art delta
  tx:    Tx          #                           desc: transaction meta
}
# -----------------------------------------------------------------------------
# Urn Bite Event Object
# -----------------------------------------------------------------------------
type BiteEvent {
  id:    Integer     # param: e.id               desc: bite/bid identifier
  ilkId: String      # param: e.ilk              desc: ilk identifier
  ilk:   Ilk         # query: Ilk(               desc: ilk object at event block height
                     #   id:    ilkId,
                     #   block: tx.blockNumber
                     # )
  urnId: String      # param: e.urn              desc: urn identifier
  urn:   Urn         # query: Urn(               desc: urn object at event block height
                     #   id:    urnId,
                     #   ilkId: ilkId,
                     #   block: tx.blockNumber
                     # )
  bid:   Bid         # query: Bid(id: id        desc: bid object at event block height
                     #   id:    id,
                     #   block: tx.blockNumber
                     # )
  lot:   Float       # param: e.lot              desc: siezed collateral
  art:   Float       # param: e.art              desc: siezed debt
  tab:   Float       # param: e.tab              desc: debt to recover
  tx:    Tx          #                           desc: transaction meta
}

# Vow.fess.call -> create Sin era: now
# Vow.flog.call -> update Sin era: e.era => flogged
type Sin {
  era:     Integer     # param: e.era               desc: bite timestamp
  tab:     Float       # store: sin[era]            desc: sin amount
  events:  SinEvent    # query: SinEvent(era: era)  desc: fess & flog events
  flogged: Boolean     #                            desc: true if flogged
  created: Datetime
  updated: Datetime
}



# Vow.fess.call -> create SinEvent era: now
# Vow.flog.call -> create SinEvent era: e.era
type SinEvent {
  era:    Integer  # param: e.era desc: flogs storage key
  tx:     Tx       #              desc: transaction meta
}

type Query {

   # Collection Arguments
   # first: Only read the first `n` values # of the set.
   # last: Only read the last `n` values # of the set.
   # offset: Skip the first `n` values from our `after`
   # cursor, an alternative to cursor based pagination. May
   # not be used with `last`.
   # before: Read all values in the set
   # before (above) this cursor.
   # after: Read all values in the set
   # after (below) this cursor.
   # orderBy: The method to use when ordering `OasisTrade`.
   # condition: A condition to be used in determining which values should be
   # returned by the collection.
   # filter: A filter to be used in determining which values should be returned
   # by the collection.

   allIlks(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   IlkOrderBy,
     condition: IlkCondition,
     filter:    IlkFilter
   ): [Ilk]

   allIlkStates(
     # Collection arguments
     # ...
     interval: String # optionally specify a postgres aggregation interval e.g '1 day'
   ): [Ilk]

   getIlk(
     id: String!
     blockNumber: Int # optionally retrieve ilk state at a given block height
   ): Ilk

   allUrns(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   UrnOrderBy,
     condition: UrnCondition,
     filter:    UrnFilter
   ): [Urn]

   getUrn(
     ilkId: String!
     urnId: String!
     blockNumber: Int # optionally retrieve ilk state at a given block height
   ): Urn

   allUrnStates(
     # Collection arguments
     # ...
     interval: String # optionally specify a postgres aggregation interval e.g '1 day'
   ): [Urn]

   allIlkFiles(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   IlkFileOrderBy,
     condition: IlkFileCondition,
     filter:    IlkFileFilter
   ): [IlkFileEvent]

   allFrobs(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   FrobOrderBy,
     condition: FrobCondition,
     filter:    FrobFilter
   ): [FrobEvent]

   allBites(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   BiteOrderBy,
     condition: BiteCondition,
     filter:    BiteFilter
   ): [BiteEvent]
}
